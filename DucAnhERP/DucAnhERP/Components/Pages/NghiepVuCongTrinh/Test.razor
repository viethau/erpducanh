@page "/NghiepVuCongtrinh/Test"
@using Microsoft.AspNetCore.SignalR.Client;
@inject NavigationManager Navigation
@implements IAsyncDisposable
@inject DataService DataService

<h3>Dữ liệu hiển thị</h3>

<button @onclick="AddData">Thêm dữ liệu</button>
<button @onclick="UpdateData">Cập nhật dữ liệu</button>
<button @onclick="DeleteData">Xóa dữ liệu</button>

<ul>
    @foreach (var item in data)
    {
        <li>@item</li>
    }
</ul>

@code {
    private HubConnection? hubConnection;
    private List<string> data = new List<string>();

    protected override async Task OnInitializedAsync()
    {
        // Khởi tạo kết nối SignalR
        hubConnection = new HubConnectionBuilder()
            .WithUrl(Navigation.ToAbsoluteUri("/dataUpdateHub"))
            .Build();

        // Đăng ký nhận thông báo khi dữ liệu thay đổi
        hubConnection.On("ReceiveDataUpdate", async () =>
        {
            // Gọi lại dữ liệu mới từ server khi có thay đổi
            await LoadData();
        });

        // Bắt đầu kết nối với Hub
        await hubConnection.StartAsync();

        // Tải dữ liệu ban đầu
        await LoadData();
    }

    private async Task LoadData()
    {
        // Giả sử bạn gọi dịch vụ để lấy dữ liệu từ server
        // data = await _dataService.GetDataAsync();

        // Cập nhật lại giao diện
        data.Clear();
        data.Add("Dữ liệu mới 1");
        data.Add("Dữ liệu mới 2");
        data.Add("Dữ liệu mới 3");

        StateHasChanged(); // Cập nhật lại giao diện
    }

    private async Task AddData()
    {
        var a = "";
        // Thêm dữ liệu và thông báo cho tất cả các client
        await DataService.AddDataAsync("Dữ liệu mới được thêm");
    }

    private async Task UpdateData()
    {
        // Cập nhật dữ liệu và thông báo cho tất cả các client
        await DataService.UpdateDataAsync("Dữ liệu đã được cập nhật");
    }

    private async Task DeleteData()
    {
        // Xóa dữ liệu và thông báo cho tất cả các client
        await DataService.DeleteDataAsync("Dữ liệu đã bị xóa");
    }

    public async ValueTask DisposeAsync()
    {
        if (hubConnection is not null)
        {
            await hubConnection.DisposeAsync();
        }
    }
}













@* @using Blazor.Diagrams
@using Blazor.Diagrams.Core.Models
@using Blazor.Diagrams.Core.Anchors
@using Blazor.Diagrams.Core.Geometry
@using Blazor.Diagrams.Core.Routers
@using Blazor.Diagrams.Core.PathGenerators
@using Blazor.Diagrams.Components
@using Blazor.Diagrams.Options
@inject IJSRuntime JSRuntime

<div class="diagram-container">
    <CascadingValue Value="Diagram" IsFixed="true">
        <DiagramCanvas></DiagramCanvas>
    </CascadingValue>
</div>

<style>
    .diagram-container {
        width: 100%;
        height: 500px;
        border: 1px solid black;
    }
</style>

@code {
    private BlazorDiagram Diagram { get; set; } = null!;
    private int verticalSpacing = 80; // Khoảng cách dọc giữa các node
    private int horizontalSpacing = 150; // Khoảng cách ngang giữa các node

    protected override void OnInitialized()
    {
        var options = new BlazorDiagramOptions
            {
                AllowMultiSelection = true,
                Zoom = { Enabled = false },
                Links =
            {
                DefaultRouter = new NormalRouter(),
                DefaultPathGenerator = new SmoothPathGenerator()
            },
            };

        Diagram = new BlazorDiagram(options);

        string formula1 = "=IF(AND(JC22=\"Có\",IZ22=\"Tường xây gạch\"),IF(JA22=\"Không mũ mố\",JO22,JO22+JP22+JR22),IF(AND(JC22=\"Không\",JA22=\"Mũ mố xây gạch\"),JR22+JS22,0))";
        InitializeDiagramFromFormula(formula1);
    }

    private void InitializeDiagramFromFormula(string formula)
    {
        var startNode = CreateNode("Start", new Point(300, 50));
        var endNode = CreateNode("End", new Point(300, 500));
        ParseFormula(formula, startNode, endNode, 1);
    }

    private void ParseFormula(string formula, NodeModel currentNode, NodeModel endNode, int level)
    {
        if (formula.StartsWith("=IF("))
        {
            int startIndex = formula.IndexOf('(') + 1;
            int endIndex = formula.LastIndexOf(')');
            string content = formula.Substring(startIndex, endIndex - startIndex);
            var parts = content.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);

            if (parts.Length > 0)
            {
                var conditionNode = CreateNode(parts[0].Trim(), new Point(currentNode.Position.X, currentNode.Position.Y + verticalSpacing * level));
                ConnectNodes(currentNode, conditionNode);

                // Xử lý phần true
                if (parts.Length > 1)
                {
                    var trueNode = CreateNode(parts[1].Trim(), new Point(conditionNode.Position.X + horizontalSpacing, conditionNode.Position.Y));
                    ConnectNodes(conditionNode, trueNode, "True", LinkMarker.Arrow);
                    ParseFormula(parts[1].Trim(), trueNode, endNode, level + 1);

                    // Thêm node kết quả cho phần true
                    var trueResultNode = CreateNode("Result: " + parts[1].Trim(), new Point(trueNode.Position.X + horizontalSpacing, trueNode.Position.Y));
                    ConnectNodes(trueNode, trueResultNode, "Result", LinkMarker.Arrow);
                    ConnectNodes(trueResultNode, endNode);
                }
                else
                {
                    ConnectNodes(conditionNode, endNode, "True", LinkMarker.Arrow);
                }

                // Xử lý phần false
                if (parts.Length > 2)
                {
                    var falseNode = CreateNode(parts[2].Trim(), new Point(conditionNode.Position.X + horizontalSpacing, conditionNode.Position.Y - verticalSpacing));
                    ConnectNodes(conditionNode, falseNode, "False", LinkMarker.Arrow);
                    ParseFormula(parts[2].Trim(), falseNode, endNode, level + 1);

                    // Thêm node kết quả cho phần false
                    var falseResultNode = CreateNode("Result: " + parts[2].Trim(), new Point(falseNode.Position.X + horizontalSpacing, falseNode.Position.Y));
                    ConnectNodes(falseNode, falseResultNode, "Result", LinkMarker.Arrow);
                    ConnectNodes(falseResultNode, endNode);
                }
                else
                {
                    ConnectNodes(conditionNode, endNode, "False", LinkMarker.Arrow);
                }
            }
        }
        else if (formula.Contains("AND") || formula.Contains("OR"))
        {
            int functionStartIndex = formula.IndexOfAny(new[] { 'A', 'O' });
            int startIndex = formula.IndexOf('(') + 1;
            int endIndex = formula.LastIndexOf(')');
            string content = formula.Substring(startIndex, endIndex - startIndex);
            var conditions = content.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);

            foreach (var condition in conditions)
            {
                var conditionNode = CreateNode(condition.Trim(), new Point(currentNode.Position.X, currentNode.Position.Y + verticalSpacing * level));
                ConnectNodes(currentNode, conditionNode);
                currentNode = conditionNode;
            }
            ConnectNodes(currentNode, endNode);
        }
        else
        {
            ConnectNodes(currentNode, endNode);
        }
    }

    private NodeModel CreateNode(string title, Point position)
    {
        return Diagram.Nodes.Add(new NodeModel(position) { Title = title });
    }

    private void ConnectNodes(NodeModel source, NodeModel target, string? label = null, LinkMarker? marker = null)
    {
        var link = Diagram.Links.Add(new LinkModel(
            new ShapeIntersectionAnchor(source),
            new ShapeIntersectionAnchor(target)
        ));

        if (label != null)
        {
            link.Labels.Add(new LinkLabelModel(link, label));
        }

        if (marker != null)
        {
            link.TargetMarker = marker;
        }
    }
}
  *@